---
# Front matter
title: "Отчет по лабораторной работе №1"
subtitle: "Использование git"
author: "Исаханян Эдуард Тигранович"
group: NFIbd-01-19
institute: RUDN University, Moscow, Russian Federation
date: 2022 Feb 11th

# Generic otions
lang: ru-RU
toc-title: "Содержание"

# Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

# Pdf output format
toc: true # Table of contents
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
### Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Misc options
indent: true
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---
# Цель работы  
Цель данной лабораторной работы является ознакомление с git.  

# Задание  
В ходе работы мы должны научится создавать проекты и изменять их. Также научится индексировать и удалять изменения, добавлять, удалять и изменять коммиты, перемещать файлы, создавать новые ветки и перемещаться по веткам, слиять, решать конфликты при слиянии и перебазировать ветки, клонировать репозитории, создавать чистые репозитории.

# Теоретическое введение
Описание основных команд git.

|Имя команды | описание команды                                |
|------------|-------------------------------------------------|
|git config  | Позволяет настроить значение конфигурации       |
|git init    | Создает новый проект                            |
|git status  | Показывает состояние репозитория                |
|git reset   | Убирает индексацию                              |
|git add     | Добавляет индексацию                            |
|git commit  | Фиксирует в коммите проиндексированные изменения|
|git log     | Показывает список коммитов                      |
|git tag     | Позволяет дать тег текущему состоянию на коммите|
|cat         | Показывает содержимое файла                     |
|git revert  | Отменяет новый коммит                           |
|git merge   | Сливает текущую ветку с указанным               |
|git clone   | Копирует репозиторий                            |
|git branch  | Создает новую ветку                             |
|git pull    | Загружает данные с внешнего репозитория         |

# Выполнение лабораторной работы

**1.Подготовка**		
	*1.1. установка имени и электронной почты*  
		Первое что нужно сделать это установить имя и электронную почту, для того чтобы git узнавал нас.  
		![установка имени и электронной почты](images/image1.png)  
	*1.2. Установка окончаний строк*  
		Настраиваем core.autocrlf с параметрами true, чтобы сделать все переводы  
		строк текстовых файлов в главном репозитории одинаковы. Устанавливаем core.safecrlf в warn.  	
		![Установка окончаний строк](images/image2.png)  
	*1.3. Установка отображения unicode*  
		Git по умолчанию не печатает ASCII, и чтобы избежать нечитаемых строк, установим отображение unicode.  
		![Установка отображения unicode](images/image3.png)  

**2. Создание проекта**  
	*2.1. Создание страницу "Hello,World!"**  
		Для начала создаем пустой каталог с именем hello, затем заходим в него и создаем там файл с именем hello.html.  
		![Создание проекта](images/image4.png)  
		![Создание проекта](images/image5.png)  
	*2.2. Создание репозитория*  
		Чтобы создать git репозиторий из этого каталога, нужно выполнить команду git init.  
		![Создание репозитория](images/image7.png)  
	*2.3. Добавление файла в репозиторий*  
		Добавим файл в репозиторий.  
		![Добавление файла в репозиторий](images/image5.png)  
	*2.4. Проверка состояние репозитория*  
		Используем команду git status, чтобы проверить текущее состояние репозитория.  
		![Проверка состояние репозитория](images/image8.png)   
		И мы видим, что коммитить нечего. Это означает, что в репозитории хранится текущее состояние рабочего каталога, и нет никаких
		изменений, ожидающих записи.  

**3. Внесение изменений**  
	*3.1 Изменение  страницы «Hello, World»*  
	Добавим кое-какие HTML-теги к нашему приветствию.  
	![Изменение  страницы «Hello, World»](images/image10.png)  

**4. Индексация изменений**  
	*4.1. Индексация*  
		Индексируем изменения и проверим статус.  
		![Индексация](images/image11.png)  
		Мы видим, что git знает об изменениях, но изменение пока не записано в репозиторий.  
	*4.2. Коммит*  
		Сделаем коммит без -m, откроется редактор и там напишем «Added h1 tag».  
		![Коммит](images/image12.png)  
*4.3. Добавить стандартные теги страницы*  
	Изменим страницу «Hello, World», чтобы она содержала стандартные теги < html> и < body>.  
	![стандартные теги](images/image13.png)  
	Теперь добавим это изменение в индекс git.  
	![добавим это изменение в индекс git](images/image14.png)  
	Добавим заголовки HTML (секцию < head>) к странице «Hello, World».  
	![Добавление < head>](images/image15.png)  
	Проверим текущий статус.  
	![текущий статус](images/image16.png)  
	Видим, что hello.html указан дважды в состоянии. Первое изменение (добавление стандартных тегов) проиндексировано и готово к коммиту. Второе изменение (добавление заголовков HTML) является не проиндексированным. Если бы мы делали коммит сейчас, заголовки не были бы сохранены в репозиторий.    
	Произведем коммит проиндексированного изменения, а затем еще раз проверим состояние.  
	![коммит стандартных тегов](images/image17.png)  
	![текущий статус](images/image18.png)    
	Состояние команды говорит нам о том, что hello.html имеет незафиксированные изменения, но уже не в буферной зоне.  
	Теперь добавим второе изменение в индекс, а затем сделаем коммит.  
	![второе изменение](images/image19.png)    
	В качестве файла для добавления, мы использовали текущий каталог ().. Это 
	краткий и удобный путь для добавления всех изменений в файлы текущего каталога
	и его подкаталоги.  
*4.4. История*  
	Получим список произведенных изменений.  
	![список произведенных изменений](images/image20.png)  
*4.5. Получение старых версий*
Изучим данные лога и найдем хэш для первого коммита. Он должен быть в
последней строке данных. Используем этот хэш-код, чтобы вернуть состояние к начальному.  
![возврат к начальному состоянию](images/image21.png)  
Проверим, что мы вернулись назад.  
![проверка](images/image22.png)  
Вернемся к последней версии через master и проверим это.
![возвращение к последней версии](images/image23.png)  
*4.6. Создание тегов версий*  
Назовем текущую версию страницы hello v1.  
![добавление тега](images/image24.png)  
Теперь текущая версия страницы называется v1.  
Создадим тег для версии, которая идет
перед текущей версией и назовем его v1-beta. В первую очередь нам надо переключиться на предыдущую версию. Вместо поиска до хэш, мы будем использовать
^, обозначающее «родитель v1».  
![возвращенние к состояние до тега](images/image25.png)  
![проверка](images/image26.png)  
*4.7 Просмотр тегов*  
Мы можем посмотреть теги в логе.  
![просмотр тегов в логе](images/image27.png)   
Мы видим теги (v1 и v1-beta) в логе вместе с именем ветки (master).
Кроме того, HEAD показывает коммит, на который мы переключились.  

**5. Отмена локальных изменений**  
*5.1. Изменим hello.html*  
Иногда случается, что мы изменили файл в рабочем каталоге, и хотим отменить
последние коммиты. С этим справится команда git checkout.
Добавим в hello.html нежелательный комментарий.  
![нежелательный комментарий](images/image28.png)   
*5.2. Отмена изменений в рабочем каталоге*  
Используем команду git checkout для переключения версии файла
hello.html в репозитории.  
![возвращение в состояние до нежелательного комментария](images/image29.png)  

**6. Отмена проиндексированных изменений**   
Добавим в hello.html нежелательный комментарий.  
![нежелательный комментарий](images/image30.png)  
Проиндексируем это изменение и отменим индексацию.  
![индексикация и отмена](images/image31.png)  
Команда git reset сбрасывает буферную зону к HEAD. Это очищает буферную
зону от изменений, которые мы только что проиндексировали.
Команда git reset (по умолчанию) не изменяет рабочий каталог. Поэтому
рабочий каталог все еще содержит нежелательный комментарий. Мы можем использовать команду git checkout, чтобы удалить нежелательные изменения в
рабочем каталоге.  
![удаление нежелательных изменений](images/image32.png)  
Наш рабочий каталог опять чист.  

**7. Отмена коммитов**  
![нежелательный комментарий](images/image33.png)  
![индексикация и коммит](images/image34.png)  
Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом.  
![отмена коммита](images/image36.png)  
Перейдем в редактор, где мы можем отредактировать коммит-сообщение по
умолчанию или оставить все как есть.  
![редактор](images/image35.png)  
Посмотрим, что у нас в логе.  
![просмотр лога](images/image37.png)  
Проверка лога показывает нежелательные и отмененные коммиты в наш репозиторий.  

**8. Удаление коммитов из ветки**  
Отметим тегом это состояние и сбросим коммит к предшествующим коммиту Oops.    
![отметка тегом и сброс коммита](images/image38.png)    
Проверим  удалили ли мы этот коммит.  
![проверка лога](images/image39.png)  
Но если мы посмотрим на все коммиты, то увидим, что ошибочный коммит не исчез.  
![просмотр всех коммитов](images/image40.png)  
Давайте удалим этот коммит с помощью тега.  
![удаление с помощью тега](images/image41.png)  
Проверим исчезли ли коммиты.  
![проверка](images/image42.png)  

**9. Внесение изменений в коммиты**  
Изменим страницу добавим имя и фамилию.   
![добавления имени](images/image43.png)  
Проиндексируем и сделаем коммит.  
![индексация и коммит](images/image44.png)  
Теперь добавим электронную почту.  
![электронная почта](images/image45.png)  
Мы не хотим создавать отдельный коммит только ради электронной
почты. Поэтому изменим предыдущий коммит, включив в него адрес электронной
почты.   
![изменение старого коммита](images/image46.png)  
Посмотрим изменился ли наш коммит.  
![проверка](images/image47.png)  

**10. Перемещение файлов**  
Давайте создадим новый каталог и перенесем страницу в каталог lib. Затем сделаем коммит этого перемещения.  
![новый каталог](images/image48.png)  
И добавим новый файл под именем index.html.  
![созданеи index.html](images/image49.png)  
![содержимое index.html](images/image50.png)  

**11. Каталог .git**  
Посмотрим содержимое каталога .git и посмотрим базу данных объектов, мы увидим имена которых состоят из 2 символов. Это имена каталогов являются первыми двумя буквами хэша.  
![содержимое .git и .git/objects](images/image51.png)  
Также посмотрим на какой-нибудь хэш в данных объектов и настройки конфигурации.  
![содержимое .git/objects и настройки](images/image52.png)  
посмотрим на содержимое веток и тегов.  
![содержимое веток и тегов](images/image53.png)  
Также посмотрим на содержимое HEAD.  
![содержимое веток и тегов](images/image54.png)  
Мы видим, что содержимое HEAD это ссылка на текущую ветку, в данный момент это ветка master.  

**12. Работа непосредственно с объектами git**  
Посмотрим на наш последний коммит.  
![последний коммит](images/image55.png)  
Посмотрим на данные последнего коммита.  
![данные последнего коммита](images/image56.png)  
посмотрим на данные дерево.  
![данные дерево](images/image57.png)  
Затем посмотрим на данные каталога lib.  
![данные lib](images/image58.png)  
И посмотрим на что хранится в hello.html.  
![содержимое hello.html](images/image59.png)  

**13. Создание ветки**  
Давайте создадим новую ветку и назовём «style».  
![новая ветка](images/image60.png)  
Добавим файл стилей style.css.  
![создание style.css](images/image61.png)  
![индексикация и коммит](images/image62.png)  
Обновим файл hello.html, чтобы использовать стили style.css.  
![обновление hello.html](images/image63.png)  
![индексикация и коммит](images/image64.png)  
Обновим файл index.html, чтобы он тоже использовал style.css.  
![обновление index.html](images/image65.png)  
![индексикация и коммит](images/image66.png)   

**14. Навигация по веткам**  
Посмотрим на наши ветки.  
![лог с ветками](images/image67.png)  
Вернемся на ветку master и проверим, что мы на ветке master.  
![ветка master](images/image68.png)  
Вернемся на ветку style и проверим это.  
![ветка style](images/image69.png)  

**15. Изменения в ветке master**  
Создадим файл README в ветке master.  
![README](images/image70.png)  
![индексикация и коммит](images/image71.png)  
Теперь у нас в репозитории есть две отличающиеся ветки. Используем лог-команду для просмотра веток и их отличий.  
![лог-команду](images/image72.png)  

**16. Слияние**  
Слияние переносит изменения из двух веток в одну. Давайте вернемся к ветке
style и сольем master с style.  
![слияние](images/image73.png)  
![слияние](images/image74.png)  
Путем периодического слияния ветки master с веткой style мы можем переносить из master любые изменения и поддерживать совместимость изменений
style с изменениями в основной ветке.  
Теперь попробуем создать конфликт. Для этого в ветке master зайдем в файл hello.html и немного изменим его.  
![создание конфликта](images/image75.png)  
![индексикация и коммит](images/image76.png)  
![Просмотр лога](images/image77.png)  
После попытки слить master с style наш файл hello.html изменился, и чтобы решить этот конфликт нужно вручную изменить файл.  
![попытка слияния](images/image78.png)  
![конфликтный файл](images/image79.png)  
![решение конфликта](images/image80.png)  
И сделаем коммит решения конфликта.  
![решение конфликта](images/image81.png)  


**17. Сброс веток**  
Перейдем на ветку style к точке перед тем, как мы слили ее с веткой master. Для этого, посмотрим на лог
и скопируем хэш до слияния, после сбросим ветку style до этого момента.  
![просмотр лонга](images/image82.png)  
![возвращение к моменту до слияния](images/image83.png)  
![просмотр лога](images/image84.png)  
Теперь пойдем на ветку master в точку перед внесением конфликтующих изменений.  
![возвращение к моменту до конфликта](images/image85.png)  
![просмотр лога](images/image86.png)   

**18. Перебазирование**  
Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки master в нашу ветку style.  
![Перебазирование](images/image87.png)  
Мы видим, что перебазирование очень похоже на слияние, однако дерево коммитов ветки style было переписано таким образом, что ветка master является
частью истории коммитов. 
![Перебазирование](images/image88.png)  

**19. Слияние в ветку master**  
После преобразования, давайте сольем изменения style в ветку master.  
![слияние](images/image89.png)  
Поскольку последний коммит ветки master прямо предшествует последнему
коммиту ветки style, git выполняет ускоренное слияние-перемотку.  
Теперь ветки style и master идентичны.  
![style=master](images/image90.png)  

**20. Клонирование репозиториев**  
Перейдем в рабочий каталог и сделаем клон вашего репозитория hello.  
![просмтотр рабочего каталога](images/image91.png)  
![создание клона](images/image92.png)  
Мы видим,что в клонированном репозитории все файлы из оригинального репозитория.  
Теперь посмотрим на историю репозитория.  
![лог клона](images/image93.png)  
Мы видим список всех коммитов в новый репозиторий, и он совпадает с историей коммитов в оригинальном репозитории. 
Единственная разница в названиях веток.  
![origin](images/image94.png)  
Мы видим, что клонированный репозиторий знает об имени по умолчанию
удаленного репозитория.  

**21. Удаленные ветки**  
Давайте посмотрим на ветки, доступные в нашем клонированном репозитории.  
![branch](images/image95.png)  
Как мы видим, в списке только ветка master. Команда git
branch выводит только список локальных веток по умолчанию. Но используя команду git branch -a мы видим все ветки.  

**22. Изменение оригинального репозитория**  
Вернемся к оригинальному репозиторию.  
![возвращение](images/image96.png)  
Создадим файл README.md.  
![README](images/image97.png)  
![индексикация и коммит](images/image98.png)  
Извлечем изменения из удаленного репозитория.  
![извечение изменений](images/image99.png)  
![лог клона](images/image100.png)  
Проверим что находится в клонированном README, сольем извлеченные изменения и проверим.  
![слияние извлеченных данных](images/image101.png)  
Вместо двух команд git fetch и git merge origin/master мы могли бы просто сделать git pull.  
![второй вариант](images/image102.png)  

**23. Добавление ветки наблюдения**  
Ветки, которые начинаются с remotes/origin являются ветками оригинального
репозитория. У нас больше нет ветки под названием style,
но система контроля версий знает, что в оригинальном репозитории ветка style
была. Поэтому добавим локальную ветку, которая отслеживает удаленную ветку.  
![добавления style](images/image103.png)  
![лог клона](images/image104.png)  

**24. Чистые репозитории**  
Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что мы будем использовать
его как рабочую директорию, поэтому вместе с файлами проекта в актуальной
версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории .git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске
(как это делается в рабочих копиях), а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория.  
![создание чистого репозитория](images/image105.png)  
Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Мы видим, что в репозитории hello.git нет рабочего каталога. По сути,
это есть не что иное, как каталог .git нечистого репозитория.

**25. Добавление удаленного репозитория**  
Давайте добавим репозиторий hello.git к нашему оригинальному репозиторию.  
![Добавление удаленного репозитория](images/image107.png)  

**26. Отправка изменений**  
Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории.  
![Изменение README](images/image106.png)  
![индексикация](images/image108.png)  
![коммит](images/image109.png)  
![отправка изменений в общий репозиторий](images/image110.png)  

**26. Извлечение общих изменений**  
Переключимся в клонированный репозиторий и извлечем изменения, только что отправленные в общий репозиторий.  
![переключение к клону](images/image111.png)  
![извлечение изменений](images/image112.png)  


# Выводы
Входе работы, мы научились использовать git, изучили основы работы с git репозиториями.

# Список литературы{.unnumbered}

::: {#refs}
:::